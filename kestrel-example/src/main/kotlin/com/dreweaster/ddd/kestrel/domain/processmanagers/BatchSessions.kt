package com.dreweaster.ddd.kestrel.domain.processmanagers

import com.dreweaster.ddd.kestrel.application.AggregateId
import com.dreweaster.ddd.kestrel.domain.*
import com.dreweaster.ddd.kestrel.domain.aggregates.user.RegisterUser
import com.dreweaster.ddd.kestrel.domain.aggregates.user.User
import java.time.Duration
import java.time.Instant

// Really important to note that any async actions, dispatched commands, emitted events will be triggered with at-least-once semantics
// If any of these fail, then they will all be re-executed. So, it's important to apply the idempotent receiver pattern
// Events emitted to self will be idempotently handled within configured period*, and will be de-duped based on event id.
//
// *Can configure how many event ids to retain in history. When not using snapshotting, this is irrelevant as all event ids
// will be retained. It comes in to play only with snapshots which can be configured to store a variable number of historic event ids
//
// It's not acceptable to run async DomainService functions outside of an async action block. Behaviour is undefined if attempted.
//
// domainModel.registerPolicy(
//    BatchSessions,
//    correlationIdSelector
//    domainServiceBuilder,
//    eventMapper,
//    actionRetryConfiguration,
//    snapshotConfiguration
// )

// Need to map external events into the Policy's own protocol
// EventIds of internal events are taken from the external event
// This approach means the event format migrations can be easily reasoned about in an isolated way

// correlationIdSelector is only necessary for mapping external events - i.e. events not generated by the process manager itself
//correlationIdSelector = { evt, metadata ->
//    when (evt) {
//        is ParkingSessionCompleted -> "${evt.parkableVehicleId}-${evt.carParkId}"
//        is ChargeableParkingSessionsBatched -> metadata.correlationId
//        is BufferingPeriodEnded -> metadata.correlationId
//    }
//}

//mapEvents {
//    event<ParkingSessionCompleted> { evt -> ParkingSessionQueued(evt.name) }
//    event<ChargeableParkingSessionsBatched> { evt -> BatchCreated }
//}
// domainModel.policyOf(BatchSessions).storeEvent(event) // This will apply any mappers as necessary
// domainModel.policyOf(BatchSessions).instancesAwaitingProcessing(pageable): Page<PolicyId> // orders by process with oldest outstanding unprocessed event
// domainModel.policyOf(BatchSessions).instanceOf(id).process()

//override suspend fun prepareContext(event: BatchSessionsEvent, state: BatchSessionsState?): BatchSessionsContext {
//    val carParkConfiguration = carParkService.getCarPark(state.carParkId)
//    return object : BatchSessionsContext {
//        override val bufferPeriod = carParkConfiguration.bufferPeriod
//    }
//}
//
// If PM can't handle event in its current state it will be marked as suspended with a failure_type of unhandlable_event_in_current_state
// Other events will continue to queue up behind the unhandlable one. It must be possible to continue processing after fixing the problem
// This is a natural part of the design.
//
// It's up tp system implementors to decide when it's appropriate to clean up old process managers - i.e. they can look for states they know are finished/done states
//
// For Events being emitted:

// Sets correlation id as the id of this process manager
// By default sets, the event id as event id of the processed event + type of emitted event (default 1:1 mapping between incoming event and outgoing event type)
// Don't try to send same event type multiple times as part of same incoming event
//
// For commands being sent:
//
// Default uses eventId as commandId sent to Aggregate
//
// Need to decide how to handle commands. Should enter failure state if


// Context

interface BatchSessionsContext : ProcessManagerContext {

    data class CarPark(val bufferingPeriod: Duration)

    val carPark: CarPark
}

// Events
sealed class BatchSessionsEvent : DomainEvent { override val tag = DomainEventTag("batch-parking-sessions-event") }

data class ParkingSessionQueued(
    val carParkId: AggregateId,
    val parkingAccountId: AggregateId,
    val parkableVehicleId: AggregateId,
    val startedAt: Instant,
    val finishedAt: Instant): BatchSessionsEvent()

data class ParkingSessionBatchCreated(
    val carParkId: AggregateId,
    val vehicle: Vehicle,
    val sessions: List<QueuedParkingSession>): BatchSessionsEvent()

object BufferingPeriodEnded: BatchSessionsEvent()
object TimedOutCreatingBatch: BatchSessionsEvent()

// States
sealed class BatchSessionsState : ProcessManagerState

object Empty : BatchSessionsState()

data class Buffering(
        val carParkId: AggregateId,
        val vehicle: Vehicle,
        val buffer: ParkingSessionBuffer): BatchSessionsState() {

    operator fun plus(queuedParkingSession: QueuedParkingSession) = copy(buffer = buffer.copy(sessions = buffer.sessions + queuedParkingSession))

    fun isWithinBufferingPeriod(timestamp: Instant) = buffer.bufferingWillCompleteAt.isAfter(timestamp)
}

data class CreatingBatch(
        val carParkId: AggregateId,
        val vehicle: Vehicle,
        val sessions: List<QueuedParkingSession>,
        val futureBuffer: ParkingSessionBuffer? = null): BatchSessionsState() {

    val containsFutureSessions = futureBuffer?.sessions?.isNotEmpty()

    val containsFutureBatch = false // TODO: Implement
}

// Value Objects
data class Vehicle(val parkingAccountId: AggregateId, val parkableVehicleId: AggregateId)
data class QueuedParkingSession(val startedAt: Instant, val finishedAt: Instant)
data class ParkingSessionBuffer(
    val sessions: List<QueuedParkingSession>,
    val bufferingStartedAt: Instant,
    val bufferingWillCompleteAt: Instant)

object BatchSessions: ProcessManager<BatchSessionsContext, BatchSessionsEvent, BatchSessionsState> {

    override val blueprint =

        processManager("batch-parking-sessions", startWith = Empty) {

            behaviour<Empty> {

                process<ParkingSessionQueued> { cxt, _, evt ->
                    goto(Buffering(
                        carParkId = evt.carParkId,
                        vehicle = Vehicle(parkingAccountId = evt.parkingAccountId, parkableVehicleId = evt.parkableVehicleId),
                        buffer = ParkingSessionBuffer(
                                    sessions = listOf(QueuedParkingSession(startedAt = evt.startedAt, finishedAt = evt.finishedAt)),
                                    bufferingStartedAt = evt.startedAt,
                                    bufferingWillCompleteAt = evt.startedAt + cxt.carPark.bufferingPeriod)
                    )).andEmit { BufferingPeriodEnded at evt.startedAt + cxt.carPark.bufferingPeriod }
                }
            }

            behaviour<Buffering> {

                process<BufferingPeriodEnded> { _, state, _ ->
                    goto(CreatingBatch(
                        carParkId = state.carParkId,
                        vehicle = state.vehicle,
                        sessions = state.buffer.sessions)
                    ).andSend { RegisterUser("", "") toAggregate User identifiedBy AggregateId() at now
                    }.andEmit { TimedOutCreatingBatch after 2.minutes() }
                }

                process<ParkingSessionQueued> { _, state, evt ->
                    when {
                        state.isWithinBufferingPeriod(evt.finishedAt) ->
                            goto(state + QueuedParkingSession(startedAt = evt.startedAt, finishedAt = evt.finishedAt))
                        else ->
                            goto(CreatingBatch(
                                carParkId = state.carParkId,
                                vehicle = state.vehicle,
                                sessions = state.buffer.sessions,
                                futureBuffer = listOf(QueuedParkingSession(startedAt = evt.startedAt, finishedAt = evt.finishedAt)))
                            ).andSend { RegisterUser("", "") toAggregate User identifiedBy AggregateId() at now
                            }.andEmit { TimedOutCreatingBatch after 2.minutes() }
                    }
                }
            }

            behaviour<CreatingBatch> {

                process<ParkingSessionQueued> { _, state, evt ->
                    goto(state.copy(futureSessions = state.futureSessions + QueuedParkingSession(startedAt = evt.startedAt, finishedAt = evt.finishedAt)))
                }

                process<ParkingSessionBatchCreated> { cxt, state, _ ->
                    when {
                        // TODO: If future queue has already built up another batch, need to continue in CreatingBatch, dispatching CreateChargeableParkingSessionsBatch command
                        state.containsFutureBatch ->
                        state.containsFutureSessions -> continueWith(
                                Buffering(
                                        parkableVehicleId = state.parkableVehicleId,
                                        carParkId = state.carParkId,
                                        sessions = state.futureQueue,
                                        bufferingStartedAt = state.futureQueue.head.startedAt,
                                        bufferingWillCompleteAt = state.futureQueue.head.startedAt.plus(cxt.bufferPeriod)
                                )
                        ) { emit(BufferingPeriodEnded).after(state.futureQueue.head.startedAt.plus(cxt.bufferPeriod)) }
                        else -> continueWith(Empty)
                    }
                }
            }
        }
}