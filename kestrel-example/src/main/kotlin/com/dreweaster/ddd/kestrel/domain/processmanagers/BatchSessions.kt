package com.dreweaster.ddd.kestrel.domain.processmanagers

import com.dreweaster.ddd.kestrel.application.AggregateId
import com.dreweaster.ddd.kestrel.domain.*
import com.dreweaster.ddd.kestrel.domain.aggregates.user.RegisterUser
import com.dreweaster.ddd.kestrel.domain.aggregates.user.User
import java.time.Duration
import java.time.Instant

// Really important to note that any async actions, dispatched commands, emitted events will be triggered with at-least-once semantics
// If any of these fail, then they will all be re-executed. So, it's important to apply the idempotent receiver pattern
// Events emitted to self will be idempotently handled within configured period*, and will be de-duped based on event id.
//
// *Can configure how many event ids to retain in history. When not using snapshotting, this is irrelevant as all event ids
// will be retained. It comes in to play only with snapshots which can be configured to store a variable number of historic event ids
//
// It's not acceptable to run async DomainService functions outside of an async action block. Behaviour is undefined if attempted.
//
// domainModel.registerPolicy(
//    BatchSessions,
//    correlationIdSelector
//    domainServiceBuilder,
//    eventMapper,
//    actionRetryConfiguration,
//    snapshotConfiguration
// )

// Need to map external events into the Policy's own protocol
// EventIds of internal events are taken from the external event
// This approach means the event format migrations can be easily reasoned about in an isolated way

// correlationIdSelector is only necessary for mapping external events - i.e. events not generated by the process manager itself
//correlationIdSelector = { evt, metadata ->
//    when (evt) {
//        is ParkingSessionCompleted -> "${evt.parkableVehicleId}-${evt.carParkId}"
//        is ChargeableParkingSessionsBatched -> metadata.correlationId
//        is BufferingPeriodEnded -> metadata.correlationId
//    }
//}

//mapEvents {
//    event<ParkingSessionCompleted> { evt -> ParkingSessionQueued(evt.name) }
//    event<ChargeableParkingSessionsBatched> { evt -> BatchCreated }
//}
// domainModel.processManagerOf(BatchSessions).storeEvent(event) // This will apply any mappers as necessary
// domainModel.processManagerOf(BatchSessions).instancesAwaitingProcessing(pageable): Page<PolicyId> // orders by process with oldest outstanding unprocessed event
// domainModel.processManagerOf(BatchSessions).instanceOf(id).process()
// domainModel.processManagerOf(BatchSessions).instanceOf(id).suspend() // Manually force a process manager to suspend from the outside
// domainModel.processManagerOf(BatchSessions).instanceOf(id).resume() // Forces a suspended process manager to resume processing from where it was suspended
// domainModel.processManagerOf(BatchSessions).instanceOf(id).resumeFrom(sequenceNumber) // Forces a suspended process manager to resume processing from a given future sequence number

//override suspend fun prepareContext(event: BatchSessionsEvent, state: BatchSessionsState?): BatchSessionsContext {
//    val carParkConfiguration = carParkService.getCarPark(state.carParkId)
//    return object : BatchSessionsContext {
//        override val bufferPeriod = carParkConfiguration.bufferPeriod
//    }
//}
//
// If PM can't handle event in its current state it will be marked as suspended with a failure_type of unhandlable_event_in_current_state
// Other events will continue to queue up behind the unhandlable one. It must be possible to continue processing after fixing the problem
// This is a natural part of the design.
//
// It's up tp system implementors to decide when it's appropriate to clean up old process managers - i.e. they can look for states they know are finished/done states
//
// For Events being emitted:

// Sets correlation id as the id of this process manager
// By default sets, the event id as event id of the processed event + type of emitted event (default 1:1 mapping between incoming event and outgoing event type)
// Don't try to send same event type multiple times as part of same incoming event
//
// For commands being sent:
//
// Default uses eventId as commandId sent to Aggregate
//
// Need to decide how to handle commands. Should enter failure state if


// Context

interface BatchSessionsContext : ProcessManagerContext {

    data class CarPark(val priceCappingPeriod: Duration)

    val carPark: CarPark
}

// Events
sealed class BatchSessionsEvent : DomainEvent { override val tag = DomainEventTag("batch-parking-sessions-event") }

data class ParkingSessionQueued(
    val carParkId: AggregateId,
    val parkingAccountId: AggregateId,
    val parkableVehicleId: AggregateId,
    val startedAt: Instant,
    val finishedAt: Instant): BatchSessionsEvent()

data class ParkingSessionBatchCreated(
    val carParkId: AggregateId,
    val vehicle: Vehicle,
    val sessions: List<QueuedParkingSession>): BatchSessionsEvent()

object BufferingPeriodEnded: BatchSessionsEvent()
data class TimedOutCreatingBatch(val completedBatchId: AggregateId): BatchSessionsEvent()

// States
sealed class BatchSessionsState : ProcessManagerState

object Empty : BatchSessionsState()

data class Buffering(
        val carParkId: AggregateId,
        val vehicle: Vehicle,
        val buffer: ParkingSessionBuffer): BatchSessionsState() {

    val bufferedSessions = buffer.sessions

    operator fun plus(queuedParkingSession: QueuedParkingSession) = copy(buffer = buffer + queuedParkingSession)

    fun isWithinBufferingPeriod(timestamp: Instant) = buffer.bufferingWillCompleteAt.isAfter(timestamp)
}

data class CreatingBatch(
        val carParkId: AggregateId,
        val vehicle: Vehicle,
        val completedBatchId: AggregateId,
        val completedBatch: List<QueuedParkingSession>,
        val futureBuffer: ParkingSessionBuffer? = null,
        val completedFutureBatches: List<List<QueuedParkingSession>> = emptyList()): BatchSessionsState() {

    fun addToFutureBuffer(session: QueuedParkingSession, carPark: BatchSessionsContext.CarPark): CreatingBatch {
        // TODO: Add completed future batch if necessary
        val newFutureBuffer = futureBuffer?: ParkingSessionBuffer.startNew(session, carPark)
        return copy(futureBuffer = newFutureBuffer)
    }

    fun withNextFutureBatch(): CreatingBatch =
        copy(
            completedBatchId = AggregateId(), // TODO: create deterministic (but unique to this batch) ID
            completedBatch = completedFutureBatches.first(),
            completedFutureBatches = completedFutureBatches.drop(1)
        )

    val isBufferingFutureSessions = futureBuffer?.sessions?.isNotEmpty() ?: false

    val containsCompletedFutureBatches = completedFutureBatches.isNotEmpty() // TODO: Implement
}

// Value Objects
data class Vehicle(val parkingAccountId: AggregateId, val parkableVehicleId: AggregateId)
data class QueuedParkingSession(val startedAt: Instant, val finishedAt: Instant)

data class ParkingSessionBuffer(val sessions: List<QueuedParkingSession>, val bufferingStartedAt: Instant, val bufferingWillCompleteAt: Instant) {

    operator fun plus(queuedParkingSession: QueuedParkingSession) = copy(sessions = sessions + queuedParkingSession)

    companion object {
        fun startNew(parkingSession: QueuedParkingSession, carPark: BatchSessionsContext.CarPark) =
            ParkingSessionBuffer(
                sessions = listOf(parkingSession),
                bufferingStartedAt = parkingSession.startedAt,
                bufferingWillCompleteAt = parkingSession.startedAt + carPark.priceCappingPeriod
            )
    }
}

object BatchSessions: ProcessManager<BatchSessionsContext, BatchSessionsEvent, BatchSessionsState> {

    override val blueprint =

        processManager("batch-parking-sessions", startWith = Empty) {

            behaviour<Empty> {

                process<ParkingSessionQueued> { cxt, _, evt ->
                    goto(Buffering(
                            carParkId = evt.carParkId,
                            vehicle = Vehicle(
                                parkingAccountId = evt.parkingAccountId,
                                parkableVehicleId = evt.parkableVehicleId
                            ),
                            buffer = ParkingSessionBuffer.startNew(
                                carPark = cxt.carPark,
                                parkingSession = QueuedParkingSession(
                                    startedAt = evt.startedAt,
                                    finishedAt = evt.finishedAt
                                )
                            )
                    )).andEmit { BufferingPeriodEnded at evt.startedAt + cxt.carPark.priceCappingPeriod }
                }
            }

            behaviour<Buffering> {

                process<BufferingPeriodEnded> { _, state, _ ->
                    val completedBatchId = AggregateId() // TODO: create deterministic (but unique to this batch) ID
                    goto(CreatingBatch(
                            carParkId = state.carParkId,
                            vehicle = state.vehicle,
                            completedBatchId = completedBatchId,
                            completedBatch = state.bufferedSessions)
                    ).andSend { RegisterUser("", "") toAggregate User identifiedBy AggregateId() at now
                    }.andEmit { TimedOutCreatingBatch(completedBatchId) after 2.minutes() }
                }

                process<ParkingSessionQueued> { cxt, state, evt ->
                    when {
                        state.isWithinBufferingPeriod(evt.finishedAt) ->
                            goto(state + QueuedParkingSession(startedAt = evt.startedAt, finishedAt = evt.finishedAt))
                        else -> {
                            val completedBatchId = AggregateId() // TODO: create deterministic (but unique to this batch) ID
                            goto(CreatingBatch(
                                    carParkId = state.carParkId,
                                    vehicle = state.vehicle,
                                    completedBatchId = completedBatchId,
                                    completedBatch = state.buffer.sessions,
                                    futureBuffer =
                                        ParkingSessionBuffer.startNew(
                                            carPark = cxt.carPark,
                                            parkingSession = QueuedParkingSession(
                                                startedAt = evt.startedAt,
                                                finishedAt = evt.finishedAt
                                            )
                                        )
                            )
                            ).andSend { RegisterUser("", "") toAggregate User identifiedBy AggregateId() at now
                            }.andEmit { TimedOutCreatingBatch(completedBatchId) after 2.minutes() }
                        }
                    }
                }
            }

            behaviour<CreatingBatch> {

                process<TimedOutCreatingBatch> { _, state, evt ->
                    when {
                        state.completedBatchId != evt.completedBatchId -> goto(state) // TODO: Is this the correct way to ignore an event?
                        else -> throw Suspend("failed_to_create_batch")
                    }
                }

                // TODO: Handle case where receiving TimedOutCreatingBatch for an old batch whilst creating a more recent one
                // Should just ignore it as we'd not have been able to advance to a new batch if the older batch hadn't been created successfully

                process<ParkingSessionQueued> { cxt, state, evt ->
                    goto(state.addToFutureBuffer(
                        session = QueuedParkingSession(startedAt = evt.startedAt, finishedAt = evt.finishedAt),
                        carPark = cxt.carPark)
                    )
                }

                // TODO: Should this double check the id is as expected? Raise an error just in case?
                process<ParkingSessionBatchCreated> { _, state, _ ->
                    when {
                        state.containsCompletedFutureBatches -> {
                            val nextState = state.withNextFutureBatch()
                            goto(nextState)
                                .andSend { RegisterUser("", "") toAggregate User identifiedBy AggregateId() at now }
                                .andEmit { TimedOutCreatingBatch(nextState.completedBatchId) after 2.minutes() }
                        }
                        state.isBufferingFutureSessions -> {
                            goto(Buffering(
                                    carParkId = state.carParkId,
                                    vehicle = state.vehicle,
                                    buffer = state.futureBuffer!!)
                            ).andEmit { BufferingPeriodEnded at state.futureBuffer.bufferingWillCompleteAt }
                        }
                        else -> goto(Empty)
                    }
                }
            }
        }
}

class ProcessManagerEntryPoint<C: ProcessManagerContext, E: DomainEvent, S: ProcessManagerState> (
        private val processManagerType: ProcessManager<C, E, S>,
        private val processManagerId: String) {

    fun process() {
        val blueprint = processManagerType.blueprint
        val behaviour = blueprint.capturedBehaviours[blueprint.startWith::class]
        val event = ParkingSessionQueued(AggregateId(), AggregateId(), AggregateId(), Instant.now(), Instant.now()) as E
        val state = blueprint.startWith
        val batchSessionsContext = object : BatchSessionsContext { override val carPark = BatchSessionsContext.CarPark(Duration.ofMinutes(100)) } as C

        val handler = behaviour?.capturedHandlers?.get(event::class)!! as (C,S,E) -> ProcessManagerStepBuilder<*,C,E,S>
        val builder = handler.invoke(batchSessionsContext, state, event)

        val executedStep = builder.execute()
        executedStep.scheduledCommands.forEach { println(it) }
        executedStep.scheduledEvents.forEach {
            when(it) {
                is SendEventLater<*,*> -> println(it.event::class)
            }
        }
    }
}

fun main(args: Array<String>) {

    fun <C: ProcessManagerContext, E: DomainEvent, S: ProcessManagerState> processManagerOf(
            processManagerType: ProcessManager<C, E, S>,
            processManagerId: String): ProcessManagerEntryPoint<C,E,S> {

        return ProcessManagerEntryPoint(processManagerType, processManagerId)
    }

    val pm = processManagerOf(BatchSessions, "")
    pm.process()
}